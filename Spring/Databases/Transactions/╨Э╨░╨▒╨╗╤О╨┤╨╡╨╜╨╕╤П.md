
1. Сначала запускаю эту транзакцию с  **REPEATABLE READ**  (c READ COMMITTED не воспроизводится. Скорее всего потому что с REPEATABLE READ  мы в этой транзакции устаревшее значение берем)

```postgresql
start transaction isolation level REPEATABLE READ;  
select pg_sleep(15);  
update accounts set age = 10 where user_id = 1;  
commit;  
```

И сразу после нее вот эту 
```postgresql
update accounts set age = 1 where user_id = 1;
```

Получаю ошибку при вызове commit первой транзакции:   ERROR: could not serialize access due to concurrent update .  Потому что сначала строку изменит нижняя транзакция. И только потом ее попробует перезаписать верхняя.
Причина: 
It indicates that the UPDATE or DELETE statement was queued behind another UPDATE/DELETE statement on the same row. That other statement finished, and due to the guarantees of the REPEATABLE READ isolation level, the statement in this session was cancelled.

**Recommended Action:**
Typically your application should automatically retry the UPDATE or DELETE when seeing this error message, whilst taking the updated state of the row into account.


2.  Запускаю первую транзакцию с  **REPEATABLE READ**. 
   
 ```postgresql
start transaction isolation level REPEATABLE READ;  
select pg_sleep(7);  
select number from  region where id = 1; -- берет значение, которое было на момент начала этой транзакции
commit;
```

Пока первая транзакция спит, запускаю вторую транзакцию:
```postgresql
start transaction isolation level READ COMMITTED;  
update region set number = 90 where id = 1;  
commit transaction;
```

Несмотря на то,  что вторая транзакция успела закоммитить  значение в 90,  первая  транзакция все-равно берет значение, которое было на момент старта первой транзакции. Хотя вроде к этому полю мы в первой транзакции обращаемся первый раз, и никак не нарушим то, что повторное чтение должно возвращать то же самое. Т.е  раз мы его не читали еще, то можно было бы  закоммиченное второй транзакцией значение 90 взять, как более актуальное.  Но работает не так.  В транзакции с repeatable_read считаем актуальным то, что было на момент старта этой транзакции. 




3.  В постгрес `READ UNCOMMITTED` не работает.    PostgreSQL does not support dirty reads (`READ UNCOMMITTED`). As @a_horse_with_no_name pointed out, [the manual](http://www.postgresql.org/docs/current/static/sql-set-transaction.html) says:

> The SQL standard defines one additional level, `READ UNCOMMITTED`. In PostgreSQL `READ UNCOMMITTED` is treated as `READ COMMITTED`.




4. Запускаю первую транзакцию
```postgresql
start transaction isolation level READ COMMITTED;
update region set number = 100 where id = 1;
select pg_sleep(20);
select number from region where id = 1;
commit transaction ;
select pg_sleep(3);
select number from region where id = 1;
```

Потом вторую, пока первая транзакция спит:

```postgresql
start transaction isolation level READ COMMITTED ;
update region set number = 200 where id = 1;
commit transaction ;
```
Во второй транзакции  update будет заблокирован, потому что первая транзакция залочила поле с id=1, и разлочится оно только после завершения первой транзакции.
Первый select первой транзакции вернет 100, потому что вторая вторая все еще ждет завершения первой.
Второй селект первого скрипта (после коммита) вернет 200, потому что после коммита первой транзакции, вторая транзакция заменит значение на 200.




5.  Пусть изначальное значение number = 0.  
   Запускаем сначала эту транзакцию: 
```postgresql
start transaction isolation level READ COMMITTED;
update region set number = 100 where id = 1;
select pg_sleep(7);
commit transaction;
```
Потом эту :
```postgresql
start transaction isolation level READ COMMITTED;
update region set number = 200 where id = 1 and number = 100; --тут ничего не выполнится
select number from region where id = 1; -- будет 0 (изначальное значение этого поля до обеих транзакций)
select pg_sleep(20);
update region set number = 200 where id = 1 and number = 100; --другая транзакция закоммитилась, и поэтому тут where выполнится
select number from region where id = 1; -- 200 вернется
commit transaction;
```

Во второй транзакции ничего не блочится. В первом update второй транзакции where не выполнится, потому что первая транзакция еще не закоммитила значение 100(оно всё еще 0). Второй update уже засеттит 200, потому что первая транзакция закоммитила 100, и where уже выполняется.


6. Пусть изначально значение number = 100.
   Запустим сначала эту первую транзакцию:
   ```postgresql
start transaction isolation level READ COMMITTED;
update region set number = 111 where id = 1;
select pg_sleep(7);
commit transaction;
```

Потом вторую : 
```postgresql
start transaction isolation level READ COMMITTED;
update region set number = 200 where id = 1 and number = 100; --блочится, потому что в другой транзакции заблочили строку с id = 1. Потом number сеттится в 111 в первой транзакции и коммитится. 
select number from region where id = 1; -- будет 111
update region set number = 200 where id = 1 and number = 100; --тут тоже where уже не подходит,поэтому не выполнится
select number from region where id = 1; -- будет 111
commit transaction;
```

Первый update второй транзакции после блокировки  пересчитывает where, и он перестает подходить, т.к number теперь 111 .  Поэтому 200 не сеттится первым update.  Далее select вернет 111.  Второй update тоже ничего не сделает, потому что where не пройдет.


Обычно блочатся только те строки, которые в where попадают.





6. 
The _special case_  where Postgres can lose an update, it's where the larger system Postgres is a part of, appears to lose an update. The case in question requires users in concurrent transactions to re-use values read previously, disregarding the fact that between the initial read and its re-use, someone's commit might have rendered the value outdated.

Thing is, if you want to do things that way, you're supposed to use [`repeatable read` mode](https://www.postgresql.org/docs/current/transaction-iso.html#XACT-REPEATABLE-READ) and/or [`select for update`](https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE) (or another [explicit lock](https://www.postgresql.org/docs/current/explicit-locking.html)), locking the rows you plan to update.

In the [PDF version](https://edu.postgrespro.com/postgresql_internals-14_part1_en.pdf) the quote you refer to is on page 44. Page 52 describes said case of lost update:

> The application reads and registers (outside of the database) the current balance of Alice’s account:
> 
> ```sql
>  => BEGIN;
>  => SELECT amount FROM accounts WHERE id = 1;
>  amount
>  −−−−−−−−
>  800.00
>  (1 row)
> ```
> 
> Meanwhile, the other transaction does the same:
> 
> ```sql
>  => BEGIN;
>  => SELECT amount FROM accounts WHERE id = 1;
>  amount
>  −−−−−−−−
>  800.00
>  (1 row)
> ```
> 
> The first transaction increases the previously registered value by $800 and commits this change:
> 
> ```sql
> => UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1
> RETURNING amount;
> amount
> −−−−−−−−
> 900.00
> (1 row)
> UPDATE 1
> => COMMIT;
> ```
> 
> The second transaction does the same:
> 
> ```sql
> => UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1
> RETURNING amount;
> amount
> −−−−−−−−
> 900.00
> (1 row)
> UPDATE 1
> ```
> 
> Unfortunately, Alice has lost $100. The database system does not know that the registered value of $800 is somehow related to accounts.amount, so it cannot prevent the lost update anomaly. At the Read Committed isolation level, this code is incorrect.




7. - `INSERT ... ON CONFLICT` in read committed isolation:
    
    If transaction 1 has inserted a row, but not yet committed, transaction 2 running `INSERT ... ON CONFLICT` will wait until transaction 1 has committed or rolled back and then update or insert as appropriate. No constraint violation can occur.



8. Serializable transactions take special "SI" locks which track read and write access and survive a commit. They don't block other sessions, but are used to determine if there _may_ be a conflict. Serializable isolation level only works properly if _all_ concurrent transactions use the serializable isolation level.
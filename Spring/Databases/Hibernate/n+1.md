![[Снимок экрана 2023-08-03 в 8.33.56.png]]




Нет способа решить N+1 проблему хорошо и без проблем. каждое решение должно быть индивидуально и с учетом предметной области



![[Снимок экрана 2023-08-03 в 8.34.20.png]]

Обычный EAGER не через join будет делать, а для каждого Entity в списке дергать отдельные запросы на подтягивание его зависимостей.

EntityGraphType FETH (дефолтный). как я понял в этом случае, те аттбируты, которые мы укажем, будет обработаны через join fetch как Eager, а то,что не указано, будет обработано как Lazy, несмотря на то,  какая там аннотация стоит в Entity,  и несмотря на типы связей, для которых дефолтно должно быть Eager.

EntityGraphType LOAD отличается тем, что те аттрибуты, которые не указаны, будут обработаны в соответствии с тем,  что в Entity стоит, или в соответствии с тем,  что по дефолту должно быть для этого типа связи(если в Entity явно не стоит).  По моим экспериментам, если он стоит в Entity как Eager, и отсутствует в графе, то будет подтягиваться, но не джойном, а отдельными запросами(т.е N+1 будет для таких зависимостей)




![[Снимок экрана 2023-08-03 в 8.36.50.png]]




![[Снимок экрана 2023-08-03 в 8.37.12.png]]


Тут в селекте забыли поставить dictinct, что важно, потому что джойним коллекцию. И в версиях хибера до шестой это приведет к тому, что сущность студента получим два раза. После 6 вроде пофиксили. Можно еще избежать проблем, сделав Set вместо List.

Join fetch и entity graph - 2 инструмента, которые делают одно и то же. не надо их применять одновременно


![[Снимок экрана 2024-01-07 в 07.12.58.png]]





![[Снимок экрана 2023-08-03 в 8.38.45.png]]
![[Снимок экрана 2025-11-04 в 19.14.51.png]]



Когда у нас немаленький список студентов, то приджоинивать курсы(там ManyToMany) одним запросом уже как-то слишком, потому что размер списка играет против нас. И в этом случае лучше сделать несколько запросов, чем один огромный. 





![[Снимок экрана 2023-08-03 в 8.39.04.png]]



![[Снимок экрана 2023-08-03 в 8.39.25.png]]
для каждых n РОДИТЕЛЬСКИХ(!!!) сущностей будет сделан 1 запрос за связью.  Я так понял, работает примерно как subselect, только вместо одного запроса за связью, делает несколько, и потом "женит" с родительскими обьектами.


batchSize vs subselect.  если курсов дохуя прям, то лучше batchSize.   а если их не так много, то можно и все загрузить сразу.
## 1. High Object Creation Rate

If your application’s object creation rate is very high, then to keep up with it, the garbage collection rate will also be very high. A high garbage collection rate will increase the GC pause time as well. Thus, optimizing the application to create fewer objects is THE EFFECTIVE strategy to reduce long GC pauses. This might be a time-consuming exercise, but it is 100% worth doing. In order to optimize the object creation rate in the application, you can consider using Java profilers like [JProfiler](https://www.ej-technologies.com/products/jprofiler/overview.html), [YourKit](https://yourkit.com/), or JVisualVM. These profilers will report:

- What are the objects that have been created?
    
- What is the rate at which these objects are created?
    
- What is the amount of space they are occupying in memory?
    
- Who is creating them?
    

Always try to optimize the objects that occupy the most amount of memory. Go after the big fish in the pond.

### **Tidbit: How to Figure Out the Object Creation Rate**  
![objectstats](https://bloggceasy.files.wordpress.com/2016/11/objectstats.png?w=300&h=207)

Upload your GC log to the Universal Garbage Collection log analyzer tool [GCeasy](http://gceasy.io/). This tool will report the object creation rate. There will be field by name ‘Avg creation rate’ in the section ‘Object Stats.’ This field will report the object creation rate. Strive to keep this value lower. See the image (which is an excerpt from the [GCeasy](http://gceasy.io/)-generated report) showing the ‘Avg creation rate’ to be **8.83 mb.sec**.



## 2. Undersized Young Generation

When the young generation is undersized, objects will be prematurely promoted to the old generation. Collecting garbage from the old generation takes more time than collecting it from the young generation. Thus, increasing the young generation size has the potential to reduce long GC pauses. The young generation's size can be increased by setting one of the two JVM arguments

**-Xmn**: specifies the size of the young generation.

**-XX:NewRatio**: Specifies the size of the young generation relative to the old generation. For example, setting -XX:NewRatio=2 means that the ratio between the old and young generation is 1:2. The young generation will be half the size of the overall heap. So, if the heap size is 2 GB, then the young generation size would be 1 GB.




## 3. Choice of GC Algorithm

Your GC algorithm has a major influence on the GC pause time. If you are a GC expert or intend to become one (or someone on your team is a GC expert), you can tune GC settings to obtain optimal GC pause time. If you don’t have a lot of GC expertise, then I would recommend using the G1 GC algorithm because of its **auto-tuning** capability. In G1 GC, you can set the GC pause time goal using the system property ‘-XX:MaxGCPauseMillis.’ Example:

 -XX:MaxGCPauseMillis=200


As per the above example, the maximum GC pause time is set to 200 milliseconds. This is a soft goal, which JVM will try it’s best to meet it.


## **5. Tuning the Number of GC Threads**

WARNING: Adding too many GC threads will consume a lot of CPU and take away resources from your application. Thus you need to conduct thorough testing before increasing the GC thread count.



[[Generics]]
Для максимальной гибкости для входных параметров, представляющих производителей или потребителей, следует использовать типы с символами подстановки. Если входной параметр является и произво­ дителем, и потребителем, то типы с символами подстановки не принесут ника­кой пользы: здесь требуется точное совпадение типов, а это то, что получается без применения символов подстановки.

пример использования  ? super


например пишем свою реализацию стека
```java
 Stack<E>
```

и пишем метод
```java
 popAll(Collection<? super E> dst) 
```


в котором достаем все элементы из стека и добавляем их в переданную коллекцию. И чтобы принимать элементы стека, нам подойдет и коллекция с любым родительским типом от E. 

а    ? extends надо писать например для вот такого метода
```java
pusAll(Collection<? extends E> dst)
```

потому что мы будем добавлять элементы из входной коллекции в стек, и можем дочерние тоже передавать для добавления в стек.

PECS — producer-extends, consumer-super


Другими словами, если параметризованный тип представляет производителя Т, используйте
```java
pusAll(Iterable<? extends E> src)
```




 В нашем примере Stack параметр src метода pushAll про­изводит экземпляры Е для использования стеком, поэтому соответствующий тип для src имеет вид
 ```java
Iterable<? extends Е>;
```
  
   
   
   параметр dst метода po­pAll потребляет экземпляры Е из стека, поэтому для dst соответствующий тип имеет вид 

 ```java
 Collection<? super Е>;
```
   
   Правило PECS мнемонически от­ражает основополагающий принцип, определяющий использование типов с символами подстановки.
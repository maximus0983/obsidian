
![[Снимок экрана 2024-01-19 в 12.58.35.png]]




equals
![[Снимок экрана 2024-01-19 в 12.58.10.png]]

![[Снимок экрана 2024-01-27 в 12.52.26.png]]

Не подставляйте другойтип вместо Object в объявлении equals.За­частую программисты пишут метод equals, который выглядит, как пока­зано ниже, а затем часами разбираются, почему он не работает должным образом:

// Тип параметра должен быть Object!

public boolean equals(MyClass о) {

}

Проблема заключается в том, что этот метод не перекрывает (override) Object. equals, аргумент которого имеет тип Object, но вместо этого перегружает (overload) его (раздел 8.4). Неприемлемо предоставлять та­ кой “строго типизированный” метод equals даже в качестве дополнения к обычному, поскольку это может привести к аннотациям Override в подклассах для ложных срабатываний и создать ложное чувство безопас­ ности.

Последовательное использование аннотации Override, показанное на протяжении всего этого раздела, защитит вас от этой ошибки (раздел 6.7).



wait()

![[Снимок экрана 2024-01-19 в 13.20.51.png]]



![[Снимок экрана 2024-01-19 в 14.27.31.png]]





CLONE

![[Снимок экрана 2024-01-27 в 13.36.45.png]]